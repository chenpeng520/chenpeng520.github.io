{"meta":{"title":"ChaplinのBlog","subtitle":null,"description":null,"author":"陈 鹏","url":"https://chenpeng520.github.io"},"pages":[{"title":"categories","date":"2018-09-01T04:37:50.000Z","updated":"2018-09-01T04:38:08.540Z","comments":true,"path":"categories/index.html","permalink":"https://chenpeng520.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-01T04:29:11.000Z","updated":"2018-09-01T04:36:37.411Z","comments":true,"path":"tags/index.html","permalink":"https://chenpeng520.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-09-03T10:32:19.032Z","updated":"2018-09-03T10:32:19.032Z","comments":true,"path":"2018/09/03/hello-world/","link":"","permalink":"https://chenpeng520.github.io/2018/09/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"spark","slug":"spark","permalink":"https://chenpeng520.github.io/tags/spark/"},{"name":"RDD","slug":"RDD","permalink":"https://chenpeng520.github.io/tags/RDD/"}]},{"title":"长耗时 Job 优化利器：Spark","slug":"长耗时 Job 优化利器：Spark","date":"2018-08-29T16:00:00.000Z","updated":"2018-09-03T10:31:53.123Z","comments":true,"path":"2018/08/30/长耗时 Job 优化利器：Spark/","link":"","permalink":"https://chenpeng520.github.io/2018/08/30/长耗时 Job 优化利器：Spark/","excerpt":"长耗时 Job 优化利器：Spark引言： 传统多线程跑job遇到的问题（java多线程运行job示例图）问题：1.settle结算每天数据都达到千万级别，遇到活动高峰期会达到4千万，即使多线程cpu利用60%也得运行4小时。2.一旦运行失败重试的时间成本特别高，且影响第二天结算相关业务。3.遇到双十一618活动，数据量陡增造成fullgc，但增加节点存储提高节点性能，又会造成服务器资源的浪费。 由此可以发现，settlejob执行job很吃力，效率也很差，如下图：","text":"长耗时 Job 优化利器：Spark引言： 传统多线程跑job遇到的问题（java多线程运行job示例图）问题：1.settle结算每天数据都达到千万级别，遇到活动高峰期会达到4千万，即使多线程cpu利用60%也得运行4小时。2.一旦运行失败重试的时间成本特别高，且影响第二天结算相关业务。3.遇到双十一618活动，数据量陡增造成fullgc，但增加节点存储提高节点性能，又会造成服务器资源的浪费。 由此可以发现，settlejob执行job很吃力，效率也很差，如下图： 如果是spark会是什么样的？ 使用spark完成相同甚至更多数据的清洗，并按照相同的数据结构写入到DB，只需要花费10分钟。 结算日结分割的各个stage在spark中执行时间：（总耗时大概10分钟） 任务执行的时间线： spark是什么 Apache Spark是一个围绕速度、易用性和复杂分析构建的大数据处理框架，最初在2009年由加州大学伯克利分校的AMPLab开发，并于2010年成为Apache的开源项目之一。 参考：http://spark.apache.org/ 关键词：分布式并行计算、大数据、快速 spark架构与生态Spark Core：包含Spark的基本功能；尤其是定义RDD的API、操作以及这两者上的动作。其他Spark的库都是构建在RDD和Spark Core之上的。 Spark SQL：提供通过Apache Hive的SQL变体Hive查询语言（HiveQL）与Spark进行交互的API。每个数据库表被当做一个RDD，Spark SQL查询被转换为Spark操作。 Spark Streaming：对实时数据流进行处理和控制。Spark Streaming允许程序能够像普通RDD一样处理实时数据。 MLlib：一个常用机器学习算法库，算法被实现为对RDD的Spark操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。 GraphX：控制图、并行图操作和计算的一组算法和工具的集合。GraphX扩展了RDD API，包含控制图、创建子图、访问路径上所有顶点的操作。 Spark与hadoophadoop与spark发展时间线： hadoop分为hadoop MapReduce 与 Hadoop分布式文件系统(HDFS) hadoop MapReduce: 仅支持Map和Reduce两种操作 Map中间结果需要写磁盘 任务调度和启动开销大 无法充分利用内存 Map和Reduce都需要排序 不适合迭代计算 Spark： 丰富的API（Java、Scala、Python、R四种语言，sort、join等高效算子） DAG执行引擎，中间结果不落盘 线程池模型减少task启动开销 充分利用内存，减少磁盘IO 避免不必要的排序操作 适合迭代计算，比如机器学习算法 当然，Spark相比MapReduce还是有一个明显的缺点，就是内存的消耗是比较大的。在超大规模数据集离线计算并且时效性要求不高的情况下可以考虑优先使用MapReduce。 关系图如下： 初识spark运行流程 构建Spark Application的运行环境，启动SparkContext SparkContext向资源管理器（可以是Standalone，Mesos，Yarn）申请运行Executor资源，并启动StandaloneExecutorbackend， Executor向SparkContext申请Task SparkContext将应用程序分发给Executor SparkContext构建成DAG图，将DAG图分解成Stage、将Taskset发送给Task Scheduler，最后由Task Scheduler将Task发送给Executor运行 Task在Executor上运行，运行完释放所有资源 Spark运行特点： 每个Application获取专属的executor进程，该进程在Application期间一直驻留，并以多线程方式运行Task。这种Application隔离机制是有优势的，无论是从调度角度看（每个Driver调度他自己的任务），还是从运行角度看（来自不同Application的Task运行在不同JVM中），当然这样意味着Spark Application不能跨应用程序共享数据，除非将数据写入外部存储系统 提交SparkContext的Client应该靠近Worker节点（运行Executor的节点），最好是在同一个Rack里，因为Spark Application运行过程中SparkContext和Executor之间有大量的信息交换 讲到这里，应该可以明白：什么是spark，spark的优势，spark应用与spark集群交互的工作方式有初步了解。 （引言：大家一定很关心数据是如何在spark集群中流转以及job是如何切割分发的。） 什么是RDD？RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、元素可并行计算的集合。 弹性是什么含义？RDD的弹性表现:1、弹性之一：自动的进行内存和磁盘数据存储的切换；2、弹性之二：基于Lineage的高效容错（第n个节点出错，会从第n-1个节点恢复，血统容错）；3、弹性之三：Task如果失败会自动进行特定次数的重试（默认4次）；4、弹性之四：Stage如果失败会自动进行特定次数的重试（可以只运行计算失败的阶段）；只计算失败的数据分片； RDD 的创建方式主要有2种: 并行化(Parallelizing)一个已经存在与驱动程序(Driver Program)中的集合如set、list; 读取外部存储系统上的一个数据集，比如HDFS、Hive、HBase,或者任何提供了Hadoop InputFormat的数据源.也可以从本地读取 txt、csv 等数据集 RDD 的操作函数(operation)主要分为2种类型 Transformation 和 Action 类别 函数 区别 Transformation Map,filter,groupBy,join, union,reduce,sort,partitionBy 返回值还是 RDD,不会马上 提交 Spark 集群运行 Action count,collect,take,save, show 返回值不是 RDD,会形成 DAG 图,提交 Spark 集群运行 并立即返回结果 参考：http://spark.apache.org/docs/latest/rdd-programming-guide.html RDD的依赖关系分为两种：窄依赖(Narrow Dependencies)与宽依赖(Wide Dependencies) RDD在spark中的使用1.创建RDD对象2.DAGScheduler模块介入运算，计算RDD之间的依赖关系，RDD之间的依赖关系就形成了DAG每一个Job被分为多个Stage。划分Stage的一个主要3.依据是当前计算因子的输入是否是确定的，如果是则将其分在同一个Stage，避免多个Stage之间的消息传递开销 常用术语Application: Appliction都是指用户编写的Spark应用程序，其中包括一个Driver功能的代码和分布在集群中多个节点上运行的Executor代码 Driver: Spark中的Driver即运行上述Application的main函数并创建SparkContext，创建SparkContext的目的是为了准备Spark应用程序的运行环境，在Spark中有SparkContext负责与ClusterManager通信，进行资源申请、任务的分配和监控等，当Executor部分运行完毕后，Driver同时负责将SparkContext关闭，通常用SparkContext代表Driver Executor: 某个Application运行在worker节点上的一个进程， 该进程负责运行某些Task， 并且负责将数据存到内存或磁盘上，每个Application都有各自独立的一批Executor， 在Spark on Yarn模式下，其进程名称为CoarseGrainedExecutor Backend。一个CoarseGrainedExecutor Backend有且仅有一个Executor对象， 负责将Task包装成taskRunner,并从线程池中抽取一个空闲线程运行Task，每一个oarseGrainedExecutor Backend能并行运行Task的数量取决与分配给它的cpu个数 Cluster Manager：指的是在集群上获取资源的外部服务。目前有三种类型： Standalon : spark原生的资源管理，由Master负责资源的分配 Apache Mesos:与hadoop MR兼容性良好的一种资源调度框架 Hadoop Yarn: 主要是指Yarn中的ResourceManager Worker: 集群中任何可以运行Application代码的节点，在Standalone模式中指的是通过slave文件配置的Worker节点，在Spark on Yarn模式下就是NoteManager节点 Job: 包含多个Task组成的并行计算，往往由Spark Action触发生成， 一个Application中往往会产生多个Job Stage: 每个Job会被拆分成多组Task， 作为一个TaskSet， 其名称为Stage，Stage的划分和调度是有DAGScheduler来负责的，Stage有非最终的Stage（Shuffle Map Stage）和最终的Stage（Result Stage）两种，Stage的边界就是发生shuffle的地方 Task: 被送到某个Executor上的工作单元，但hadoopMR中的MapTask和ReduceTask概念一样，是运行Application的基本单位，多个Task组成一个Stage，而Task的调度和管理等是由TaskScheduler负责 DAGScheduler: 根据Job构建基于Stage的DAG（Directed Acyclic Graph有向无环图)，并提交Stage给TASkScheduler。 其划分Stage的依据是RDD之间的依赖的关系找出开销最小的调度方法。 TASKSedulter: 将TaskSET提交给worker运行，每个Executor运行什么Task就是在此处分配的. TaskScheduler维护所有TaskSet，当Executor向Driver发生心跳时，TaskScheduler会根据资源剩余情况分配相应的Task。另外TaskScheduler还维护着所有Task的运行标签，重试失败的Task。下图展示了TaskScheduler的作用 Spark运行模式：提问：settlespark会使用的是哪种模式？ Spark的运行模式多种多样，灵活多变，部署在单机上时，既可以用本地模式运行，也可以用伪分布模式运行，而当以分布式集群的方式部署时，也有众多的运行模式可供选择，这取决于集群的实际情况，底层的资源调度即可以依赖外部资源调度框架，也可以使用Spark内建的Standalone模式。 对于外部资源调度框架的支持，目前的实现包括相对稳定的Mesos模式，以及hadoop YARN模式 本地模式：常用于本地开发测试，本地还分别 local 和 local cluster standalone: 独立集群运行模式 该模式主要的节点有Client节点、Master节点和Worker节点。其中Driver既可以运行在Master节点上中，也可以运行在本地Client端。当用spark-shell交互式工具提交Spark的Job时，Driver在Master节点上运行；当使用spark-submit工具提交Job或者在Eclips、IDEA等开发平台上使用”new SparkConf.setManager(“spark://master:7077”)”方式运行Spark任务时，Driver是运行在本地Client端上的运行过程如下图：（参考至：http://blog.csdn.net/gamer_gyt/article/details/51833681） Yarn-Client模式 YARN-Cluster Spark Client 和 Spark Cluster的区别: 理解YARN-Client和YARN-Cluster深层次的区别之前先清楚一个概念：Application Master。在YARN中，每个Application实例都有一个ApplicationMaster进程，它是Application启动的第一个容器。它负责和ResourceManager打交道并请求资源，获取资源之后告诉NodeManager为其启动Container。从深层次的含义讲YARN-Cluster和YARN-Client模式的区别其实就是ApplicationMaster进程的区别 YARN-Cluster模式下，Driver运行在AM(Application Master)中，它负责向YARN申请资源，并监督作业的运行状况。当用户提交了作业之后，就可以关掉Client，作业会继续在YARN上运行，因而YARN-Cluster模式不适合运行交互类型的作业 YARN-Client模式下，Application Master仅仅向YARN请求Executor，Client会和请求的Container通信来调度他们工作，也就是说Client不能离开 demo演示","categories":[{"name":"技术","slug":"技术","permalink":"https://chenpeng520.github.io/categories/技术/"},{"name":"大数据","slug":"技术/大数据","permalink":"https://chenpeng520.github.io/categories/技术/大数据/"}],"tags":[{"name":"spark","slug":"spark","permalink":"https://chenpeng520.github.io/tags/spark/"},{"name":"RDD","slug":"RDD","permalink":"https://chenpeng520.github.io/tags/RDD/"},{"name":"大数据","slug":"大数据","permalink":"https://chenpeng520.github.io/tags/大数据/"},{"name":"运行模式","slug":"运行模式","permalink":"https://chenpeng520.github.io/tags/运行模式/"}]}]}